snippet dess
	describe "${1:name}" do
		${2}
	end

snippet shs
	${1:target}.should satisfy { |${2:obj}| ${3} }
	${4}

snippet on
	once

snippet its
	it "should ${1:work correctly}" do
	  ${2}
	end

snippet shh
	${1:target}.should have(${2:num}).${3:things}
	${4}

snippet she
	${1:target}.should eql(${2:value})
	${3}

snippet shnredt
	response.should_not redirect_to(${1:url})
	${2}

snippet dest
	describe ${1:Type} do
		${2}
	end

snippet conn
	controller_name :${1:controller}

snippet shbc
	${1:target}.should be_close(${2:result}, ${3:tolerance})
	${4}

snippet shhal
	${1:target}.should have_at_least(${2:num}).${3:things}
	${4}

snippet befa
	before(:all) do
		${1}
	end

snippet atl
	at_least(${1:n}).times

snippet shns
	${1:target}.should_not satisfy { |${2:obj}| ${3} }
	${4}

snippet des
	describe "${1}" do
		${2}
	end

snippet shnbko
	${1:target}.should_not be_a_kind_of(${2:klass})
	${3}

snippet shnp
	${1:target}.should_not be_${2:predicate}

snippet sef
	shared_examples_for "${1:do something}" do
	  ${2}
	end

snippet let
	let(:${1}) { ${2} }

snippet shhr
	${1:target}.should have(${2:n}).records
	${3}

snippet isn
	it { should_not ${1} }

snippet shnbr
	response.should_not be_redirect
	${1}

snippet seg
	shared_examples_for "${1:}" do
	  describe "as $1" do
	    ${2}
		end
	end

snippet ex
	exactly(${1:n}).times

snippet shre
	${1:target}.should raise_error(${2:error})
	${3}

snippet sht
	${1:target}.should throw_symble(:${2:symbol})
	${3}

snippet isbl
	it_should_behave_like '${1}'

snippet annot
	any_number_of_times

snippet desc
	require 'spec_helper'
	
	describe ${1:`Snippet_RubySpecNameFromFilename()`} do
		${2}
	end

snippet shp
	${1:target}.should be_${2:predicate}

snippet shrt
	${1:target}.should respond_to(:${2:sym})
	${3}

snippet cona
	context "after #${1:save!}" do
	  before(:each) do
	    subject.$1
		end
		${2}
	end

snippet sh
	${1:target}.should == ${2:value}
	${3}

snippet aft
	after(${1::each}) do
		${2}
	end

snippet desm
	require 'spec_helper'
	
	describe ${1:`Snippet_RubySpecNameFromFilename()`} do
		
		subject { Factory.build(:${2}) }
	
		it {should be_valid}
	
	end

snippet desrc
	describe ${1:controller}, "${2:GET|POST|PUT|DELETE} ${3:/some/path}${4}" do
		${5}
	end

snippet shne
	${1:target}.should_not eql(${2:value})
	${3}

snippet shham
	${1:target}.should have_at_most(${2:num}).${3:things}
	${4}

snippet shn
	${1:target}.should_not == ${2:value}
	${3}

snippet ant
	and_throw(${1:sym})

snippet any
	and_yield(${1:values})

snippet bef
	before(:each) do
		${1}
	end

snippet mat
	class ${1:ReverseTo}
		def initialize(${2:param})
			@$2 = $2
		end
	
		def matches?(actual)
			@actual = actual
			# Satisfy expectation here. Return false or raise an error if it's not met.
			${3:@actual.reverse.should == @$2}
			true
		end
	
		def failure_message
			"expected #{@actual.inspect} to ${4} #{@$2.inspect}, but it didn't"
		end
	
		def negative_failure_message
			"expected #{@actual.inspect} not to ${5} #{@$2.inspect}, but it did"
		end
	end
	
	def ${6:reverse_to}(${7:expected})
		${8}.new($7)
	end

snippet shnc
	lambda do
		${1}
	end.should_not change(${2:target}, :${3:method})

snippet anra
	and_raise(${1:exception})

snippet shb
	${1:target}.should be(${2:result})
	${3}

snippet resh
	require File.dirname(__FILE__) + '/../spec_helper'

snippet shbr
	response.should be_redirect
	${1}

snippet avf
	it {should accept_values_for(:${1:}, ${2})}
	it {should_not accept_values_for(:$1, ${3:nil})}
	

snippet anrb
	and_return { ${1} }

snippet shnre
	${1:target}.should_not raise_error(${2:error})
	${3}

snippet shnt
	lambda { ${1} }.should_not throw_symbol(:${2:symbol})
	${3}

snippet anr
	and_return(${1:value})

snippet shnb
	${1:target}.should_not be(${2:result})
	${3}

snippet dests
	describe ${1:Type}, "${2:description}" do
		${3}
	end

snippet shnr
	${1:mock}.should_not_receive(:${2:message})${3}
	${4}

snippet shnm
	${1:target}.should_not match(/${2:regexp}/)
	${3}

snippet desns
	describe ".${1:}" do
	
	  subject { described_class.$1${2} }
	
		it { should discover(${3})}
	
		it { should_not discover(${4})}
	
	
	end

snippet mocw
	Spec::Runner.configure do |config|
		config.mock_with :${1:mocha|flexmock|rr}
	end

snippet st
	stubs(:${1}).returns(${2})

snippet shnbio
	${1:target}.should_not be_instance_of(${2:klass})
	${3}

snippet it
	it "${1}" do
		${2}
	end

snippet shbko
	${1:target}.should be_a_kind_of(${2:class})
	${3}

snippet shnbs
	response.should_not be_success
	${1}

snippet atm
	at_most(${1:n}).times

snippet con
	context "${1}" do
	  ${2}
	end

snippet avfn
	it {should_not accept_values_for(:${1}, ${2:nil})}

snippet letf
	let(:${1:model}) do 
	  Factory.create(:${2:$1})
	end

snippet shredt
	response.should redirect_to(${1:url})
	${2}

snippet shnrt
	${1:target}.should_not respond_to(:${2:sym})
	${3}

snippet desa
	describe "${1:get} ${2:show}" do
	  subject { $1 :${3:$2} }
	
	  it { should be_${4:success} }
	
	end

snippet shc
	lambda do
		${1}
	end.should change(${2:described_class}, :${3:count}).by(${4:1})

snippet sheq
	${1:target}.should equal(${2:value})
	${3}

snippet shdm
	${1:target}.should match(/${2:regexp}/)
	${3}

snippet shtemp
	response.should render_template(:${1:template})
	${2}

snippet shr
	${1:mock}.should_receive(:${2:message})${3}
	${4}

snippet wia
	with(${1:args})
	${2}

snippet mm
	mock_model(${1:model})${2}

snippet shbio
	${1:target}.should be_instance_of(${2:class})
	${3}

snippet moc
	${1:var} = mock("${2:mock_name}"${3:, :null_object => true})
	${4}

snippet tw
	twice

snippet shnbc
	${1:target}.should_not be_close(${2:result}, ${3:tolerance})
	${4}

snippet subj
	subject { ${1:Factory.build(described_class.to_s.underscore)} }

snippet is
	it { should ${1} }

snippet shbs
	response.should be_success
	${1}

snippet shneq
		${1:target}.should_not equal(${2:value})
		${3}

